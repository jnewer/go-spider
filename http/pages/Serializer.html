<div class="article">            <div class="inner">              <header class="article-header">                <h1 class="article-title" itemprop="name">Serializer</h1>                                <a target="_blank" rel="noopener" href="https://translate.gorm.io/project/go-gorm/zh-CN" class="article-edit-link" title="改进此页面"><i class="fa fa-pencil"></i></a>                              </header>              <div class="article-content" itemprop="articleBody">                <html><head></head><body><p>Serializer is an extensible interface that allows to customize how to serialize and deserialize data with databasae.</p><p>GORM provides some default serializers: <code>json</code>, <code>gob</code>, <code>unixtime</code>, here is a quick example of how to use it.</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> {</span><br><span class="line">    Name        []<span class="type">byte</span>                 <span class="string">`gorm:"serializer:json"`</span></span><br><span class="line">    Roles       Roles                  <span class="string">`gorm:"serializer:json"`</span></span><br><span class="line">    Contracts   <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{} <span class="string">`gorm:"serializer:json"`</span></span><br><span class="line">    JobInfo     Job                    <span class="string">`gorm:"type:bytes;serializer:gob"`</span></span><br><span class="line">    CreatedTime <span class="type">int64</span>                  <span class="string">`gorm:"serializer:unixtime;type:time"`</span> <span class="comment">// store int as datetime into database</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Roles []<span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Job <span class="keyword">struct</span> {</span><br><span class="line">    Title    <span class="type">string</span></span><br><span class="line">    Location <span class="type">string</span></span><br><span class="line">    IsIntern <span class="type">bool</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">createdAt := time.Date(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, time.UTC)</span><br><span class="line">data := User{</span><br><span class="line">  Name:        []<span class="type">byte</span>(<span class="string">"jinzhu"</span>),</span><br><span class="line">  Roles:       []<span class="type">string</span>{<span class="string">"admin"</span>, <span class="string">"owner"</span>},</span><br><span class="line">  Contracts:   <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{<span class="string">"name"</span>: <span class="string">"jinzhu"</span>, <span class="string">"age"</span>: <span class="number">10</span>},</span><br><span class="line">  CreatedTime: createdAt.Unix(),</span><br><span class="line">  JobInfo: Job{</span><br><span class="line">    Title:    <span class="string">"Developer"</span>,</span><br><span class="line">    Location: <span class="string">"NY"</span>,</span><br><span class="line">    IsIntern: <span class="literal">false</span>,</span><br><span class="line">  },</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">DB.Create(&amp;data)</span><br><span class="line"><span class="comment">// INSERT INTO `users` (`name`,`roles`,`contracts`,`job_info`,`created_time`) VALUES</span></span><br><span class="line"><span class="comment">//   ("\"amluemh1\"","[\"admin\",\"owner\"]","{\"age\":10,\"name\":\"jinzhu\"}",&lt;gob binary&gt;,"2020-01-01 00:08:00")</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result User</span><br><span class="line">DB.First(&amp;result, <span class="string">"id = ?"</span>, data.ID)</span><br><span class="line"><span class="comment">// result =&gt; User{</span></span><br><span class="line"><span class="comment">//   Name:        []byte("jinzhu"),</span></span><br><span class="line"><span class="comment">//   Roles:       []string{"admin", "owner"},</span></span><br><span class="line"><span class="comment">//   Contracts:   map[string]interface{}{"name": "jinzhu", "age": 10},</span></span><br><span class="line"><span class="comment">//   CreatedTime: createdAt.Unix(),</span></span><br><span class="line"><span class="comment">//   JobInfo: Job{</span></span><br><span class="line"><span class="comment">//     Title:    "Developer",</span></span><br><span class="line"><span class="comment">//     Location: "NY",</span></span><br><span class="line"><span class="comment">//     IsIntern: false,</span></span><br><span class="line"><span class="comment">//   },</span></span><br><span class="line"><span class="comment">// }</span></span><br><span class="line"></span><br><span class="line">DB.Where(User{Name: []<span class="type">byte</span>(<span class="string">"jinzhu"</span>)}).Take(&amp;result)</span><br><span class="line"><span class="comment">// SELECT * FROM `users` WHERE `users`.`name` = "\"amluemh1\"</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Register-Serializer" class="article-heading"><a href="#Register-Serializer" class="headerlink" title="Register Serializer"></a>Register Serializer<a class="article-anchor" href="#Register-Serializer" aria-hidden="true"></a></h2><p>A Serializer needs to implement how to serialize and deserialize data, so it requires to implement the the following interface</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"gorm.io/gorm/schema"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SerializerInterface <span class="keyword">interface</span> {</span><br><span class="line">    Scan(ctx context.Context, field *schema.Field, dst reflect.Value, dbValue <span class="keyword">interface</span>{}) <span class="type">error</span></span><br><span class="line">    SerializerValuerInterface</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SerializerValuerInterface <span class="keyword">interface</span> {</span><br><span class="line">    Value(ctx context.Context, field *schema.Field, dst reflect.Value, fieldValue <span class="keyword">interface</span>{}) (<span class="keyword">interface</span>{}, <span class="type">error</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>For example, the default <code>JSONSerializer</code> is implemented like:</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// JSONSerializer json serializer</span></span><br><span class="line"><span class="keyword">type</span> JSONSerializer <span class="keyword">struct</span> {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scan implements serializer interface</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(JSONSerializer)</span></span> Scan(ctx context.Context, field *Field, dst reflect.Value, dbValue <span class="keyword">interface</span>{}) (err <span class="type">error</span>) {</span><br><span class="line">    fieldValue := reflect.New(field.FieldType)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> dbValue != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">var</span> bytes []<span class="type">byte</span></span><br><span class="line">        <span class="keyword">switch</span> v := dbValue.(<span class="keyword">type</span>) {</span><br><span class="line">        <span class="keyword">case</span> []<span class="type">byte</span>:</span><br><span class="line">            bytes = v</span><br><span class="line">        <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">            bytes = []<span class="type">byte</span>(v)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to unmarshal JSONB value: %#v"</span>, dbValue)</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        err = json.Unmarshal(bytes, fieldValue.Interface())</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    field.ReflectValueOf(ctx, dst).Set(fieldValue.Elem())</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Value implements serializer interface</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(JSONSerializer)</span></span> Value(ctx context.Context, field *Field, dst reflect.Value, fieldValue <span class="keyword">interface</span>{}) (<span class="keyword">interface</span>{}, <span class="type">error</span>) {</span><br><span class="line">    <span class="keyword">return</span> json.Marshal(fieldValue)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>And registered with the following code:</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">schema.RegisterSerializer(<span class="string">"json"</span>, JSONSerializer{})</span><br></pre></td></tr></tbody></table></figure><p>After registering a serializer, you can use it with the <code>serializer</code> tag, for example:</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> {</span><br><span class="line">    Name []<span class="type">byte</span> <span class="string">`gorm:"serializer:json"`</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Customized-Serializer-Type" class="article-heading"><a href="#Customized-Serializer-Type" class="headerlink" title="Customized Serializer Type"></a>Customized Serializer Type<a class="article-anchor" href="#Customized-Serializer-Type" aria-hidden="true"></a></h2><p>You can use a registered serializer with tags, you are also allowed to create a customized struct that implements the above <code>SerializerInterface</code> and use it as a field type directly, for example:</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> EncryptedString <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ctx: contains request-scoped values</span></span><br><span class="line"><span class="comment">// field: the field using the serializer, contains GORM settings, struct tags</span></span><br><span class="line"><span class="comment">// dst: current model value, `user` in the below example</span></span><br><span class="line"><span class="comment">// dbValue: current field's value in database</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(es *EncryptedString)</span></span> Scan(ctx context.Context, field *schema.Field, dst reflect.Value, dbValue <span class="keyword">interface</span>{}) (err <span class="type">error</span>) {</span><br><span class="line">    <span class="keyword">switch</span> value := dbValue.(<span class="keyword">type</span>) {</span><br><span class="line">    <span class="keyword">case</span> []<span class="type">byte</span>:</span><br><span class="line">        *es = EncryptedString(bytes.TrimPrefix(value, []<span class="type">byte</span>(<span class="string">"hello"</span>)))</span><br><span class="line">    <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">        *es = EncryptedString(strings.TrimPrefix(value, <span class="string">"hello"</span>))</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"unsupported data %#v"</span>, dbValue)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ctx: contains request-scoped values</span></span><br><span class="line"><span class="comment">// field: the field using the serializer, contains GORM settings, struct tags</span></span><br><span class="line"><span class="comment">// dst: current model value, `user` in the below example</span></span><br><span class="line"><span class="comment">// fieldValue: current field's value of the dst</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(es EncryptedString)</span></span> Value(ctx context.Context, field *schema.Field, dst reflect.Value, fieldValue <span class="keyword">interface</span>{}) (<span class="keyword">interface</span>{}, <span class="type">error</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello"</span> + <span class="type">string</span>(es), <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> {</span><br><span class="line">    gorm.Model</span><br><span class="line">    Password EncryptedString</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">data := User{</span><br><span class="line">    Password: EncryptedString(<span class="string">"pass"</span>),</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">DB.Create(&amp;data)</span><br><span class="line"><span class="comment">// INSERT INTO `serializer_structs` (`password`) VALUES ("hellopass")</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result User</span><br><span class="line">DB.First(&amp;result, <span class="string">"id = ?"</span>, data.ID)</span><br><span class="line"><span class="comment">// result =&gt; User{</span></span><br><span class="line"><span class="comment">//   Password: EncryptedString("pass"),</span></span><br><span class="line"><span class="comment">// }</span></span><br><span class="line"></span><br><span class="line">DB.Where(User{Password: EncryptedString(<span class="string">"pass"</span>)}).Take(&amp;result)</span><br><span class="line"><span class="comment">// SELECT * FROM `users` WHERE `users`.`password` = "hellopass"</span></span><br></pre></td></tr></tbody></table></figure></body></html>              </div>                            <div>