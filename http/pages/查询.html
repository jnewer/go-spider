<div class="article">            <div class="inner">              <header class="article-header">                <h1 class="article-title" itemprop="name">查询</h1>                                <a target="_blank" rel="noopener" href="https://translate.gorm.io/project/go-gorm/zh-CN" class="article-edit-link" title="改进此页面"><i class="fa fa-pencil"></i></a>                              </header>              <div class="article-content" itemprop="articleBody">                <html><head></head><body><h2 id="检索单个对象" class="article-heading"><a href="#检索单个对象" class="headerlink" title="检索单个对象"></a>检索单个对象<a class="article-anchor" href="#检索单个对象" aria-hidden="true"></a></h2><p>GORM 提供了 <code>First</code>、<code>Take</code>、<code>Last</code> 方法，以便从数据库中检索单个对象。当查询数据库时它添加了 <code>LIMIT 1</code> 条件，且没有找到记录时，它会返回 <code>ErrRecordNotFound</code> 错误</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 获取第一条记录（主键升序）</span></span><br><span class="line">db.First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一条记录，没有指定排序字段</span></span><br><span class="line">db.Take(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最后一条记录（主键降序）</span></span><br><span class="line">db.Last(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users ORDER BY id DESC LIMIT 1;</span></span><br><span class="line"></span><br><span class="line">result := db.First(&amp;user)</span><br><span class="line">result.RowsAffected <span class="comment">// 返回找到的记录数</span></span><br><span class="line">result.Error        <span class="comment">// returns error or nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 ErrRecordNotFound 错误</span></span><br><span class="line">errors.Is(result.Error, gorm.ErrRecordNotFound)</span><br></pre></td></tr></tbody></table></figure><blockquote class="note warn"><p>如果你想避免<code>ErrRecordNotFound</code>错误，你可以使用<code>Find</code>，比如<code>db.Limit(1).Find(&amp;user)</code>，<code>Find</code>方法可以接受struct和slice的数据。</p></blockquote><p><code>First</code> 和 <code>Last</code> 会根据主键排序，分别查询第一条和最后一条记录。 只有在目标 struct 是指针或者通过 <code>db.Model()</code> 指定 model 时，该方法才有效。 此外，如果相关 model 没有定义主键，那么将按 model 的第一个字段进行排序。 例如:</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user User</span><br><span class="line"><span class="keyword">var</span> users []User</span><br><span class="line"></span><br><span class="line"><span class="comment">// works because destination struct is passed in</span></span><br><span class="line">db.First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM `users` ORDER BY `users`.`id` LIMIT 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// works because model is specified using `db.Model()`</span></span><br><span class="line">result := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{}</span><br><span class="line">db.Model(&amp;User{}).First(&amp;result)</span><br><span class="line"><span class="comment">// SELECT * FROM `users` ORDER BY `users`.`id` LIMIT 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// doesn't work</span></span><br><span class="line">result := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{}</span><br><span class="line">db.Table(<span class="string">"users"</span>).First(&amp;result)</span><br><span class="line"></span><br><span class="line"><span class="comment">// works with Take</span></span><br><span class="line">result := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{}</span><br><span class="line">db.Table(<span class="string">"users"</span>).Take(&amp;result)</span><br><span class="line"></span><br><span class="line"><span class="comment">// no primary key defined, results will be ordered by first field (i.e., `Code`)</span></span><br><span class="line"><span class="keyword">type</span> Language <span class="keyword">struct</span> {</span><br><span class="line">  Code <span class="type">string</span></span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">}</span><br><span class="line">db.First(&amp;Language{})</span><br><span class="line"><span class="comment">// SELECT * FROM `languages` ORDER BY `languages`.`code` LIMIT 1</span></span><br></pre></td></tr></tbody></table></figure><h3 id="用主键检索" class="article-heading"><a href="#用主键检索" class="headerlink" title="用主键检索"></a>用主键检索<a class="article-anchor" href="#用主键检索" aria-hidden="true"></a></h3><p>如果主键是数字类型，您可以使用 <a href="#inline_conditions">内联条件</a> 来检索对象。 传入字符串参数时，需要特别注意 SQL 注入问题，查看 <a href="security.html">安全</a> 获取详情.</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">db.First(&amp;user, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line">db.First(&amp;user, <span class="string">"10"</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line">db.Find(&amp;users, []<span class="type">int</span>{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>})</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id IN (1,2,3);</span></span><br></pre></td></tr></tbody></table></figure><p>如果主键是字符串（例如像 uuid），查询将被写成这样：</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">db.First(&amp;user, <span class="string">"id = ?"</span>, <span class="string">"1b74413f-f3b8-409f-ac47-e8c062e3472a"</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = "1b74413f-f3b8-409f-ac47-e8c062e3472a";</span></span><br></pre></td></tr></tbody></table></figure><p>When the destination object has a primary value, the primary key will be used to build the condition, for example:</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user = User{ID: <span class="number">10</span>}</span><br><span class="line">db.First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result User</span><br><span class="line">db.Model(User{ID: <span class="number">10</span>}).First(&amp;result)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = 10;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="检索全部对象" class="article-heading"><a href="#检索全部对象" class="headerlink" title="检索全部对象"></a>检索全部对象<a class="article-anchor" href="#检索全部对象" aria-hidden="true"></a></h2><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Get all records</span></span><br><span class="line">result := db.Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users;</span></span><br><span class="line"></span><br><span class="line">result.RowsAffected <span class="comment">// returns found records count, equals `len(users)`</span></span><br><span class="line">result.Error        <span class="comment">// returns error</span></span><br></pre></td></tr></tbody></table></figure><h2 id="条件" class="article-heading"><a href="#条件" class="headerlink" title="条件"></a>条件<a class="article-anchor" href="#条件" aria-hidden="true"></a></h2><h3 id="String-条件" class="article-heading"><a href="#String-条件" class="headerlink" title="String 条件"></a>String 条件<a class="article-anchor" href="#String-条件" aria-hidden="true"></a></h3><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Get first matched record</span></span><br><span class="line">db.Where(<span class="string">"name = ?"</span>, <span class="string">"jinzhu"</span>).First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = 'jinzhu' ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Get all matched records</span></span><br><span class="line">db.Where(<span class="string">"name &lt;&gt; ?"</span>, <span class="string">"jinzhu"</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name &lt;&gt; 'jinzhu';</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IN</span></span><br><span class="line">db.Where(<span class="string">"name IN ?"</span>, []<span class="type">string</span>{<span class="string">"jinzhu"</span>, <span class="string">"jinzhu 2"</span>}).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name IN ('jinzhu','jinzhu 2');</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LIKE</span></span><br><span class="line">db.Where(<span class="string">"name LIKE ?"</span>, <span class="string">"%jin%"</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name LIKE '%jin%';</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AND</span></span><br><span class="line">db.Where(<span class="string">"name = ? AND age &gt;= ?"</span>, <span class="string">"jinzhu"</span>, <span class="string">"22"</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = 'jinzhu' AND age &gt;= 22;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Time</span></span><br><span class="line">db.Where(<span class="string">"updated_at &gt; ?"</span>, lastWeek).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE updated_at &gt; '2000-01-01 00:00:00';</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BETWEEN</span></span><br><span class="line">db.Where(<span class="string">"created_at BETWEEN ? AND ?"</span>, lastWeek, today).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE created_at BETWEEN '2000-01-01 00:00:00' AND '2000-01-08 00:00:00';</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Struct-amp-Map-条件" class="article-heading"><a href="#Struct-amp-Map-条件" class="headerlink" title="Struct &amp; Map 条件"></a>Struct &amp; Map 条件<a class="article-anchor" href="#Struct-amp-Map-条件" aria-hidden="true"></a></h3><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Struct</span></span><br><span class="line">db.Where(&amp;User{Name: <span class="string">"jinzhu"</span>, Age: <span class="number">20</span>}).First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = "jinzhu" AND age = 20 ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line">db.Where(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{<span class="string">"name"</span>: <span class="string">"jinzhu"</span>, <span class="string">"age"</span>: <span class="number">20</span>}).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = "jinzhu" AND age = 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Slice of primary keys</span></span><br><span class="line">db.Where([]<span class="type">int64</span>{<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>}).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id IN (20, 21, 22);</span></span><br></pre></td></tr></tbody></table></figure><blockquote class="note warn"><p><strong>NOTE</strong> When querying with struct, GORM will only query with non-zero fields, that means if your field’s value is <code>0</code>, <code>''</code>, <code>false</code> or other <a target="_blank" rel="noopener" href="https://tour.golang.org/basics/12">zero values</a>, it won’t be used to build query conditions, for example:</p></blockquote><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">db.Where(&amp;User{Name: <span class="string">"jinzhu"</span>, Age: <span class="number">0</span>}).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = "jinzhu";</span></span><br></pre></td></tr></tbody></table></figure><p>To include zero values in the query conditions, you can use a map, which will include all key-values as query conditions, for example:</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">db.Where(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{<span class="string">"Name"</span>: <span class="string">"jinzhu"</span>, <span class="string">"Age"</span>: <span class="number">0</span>}).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = "jinzhu" AND age = 0;</span></span><br></pre></td></tr></tbody></table></figure><p>For more details, see <a href="#specify_search_fields">Specify Struct search fields</a>.</p><h3 id="指定结构体查询字段" class="article-heading"><a href="#指定结构体查询字段" class="headerlink" title="指定结构体查询字段"></a><span id="specify_search_fields">指定结构体查询字段</span><a class="article-anchor" href="#指定结构体查询字段" aria-hidden="true"></a></h3><p>When searching with struct, you can specify which particular values from the struct to use in the query conditions by passing in the relevant field name or the dbname to <code>Where()</code>, for example:</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">db.Where(&amp;User{Name: <span class="string">"jinzhu"</span>}, <span class="string">"name"</span>, <span class="string">"Age"</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = "jinzhu" AND age = 0;</span></span><br><span class="line"></span><br><span class="line">db.Where(&amp;User{Name: <span class="string">"jinzhu"</span>}, <span class="string">"Age"</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE age = 0;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="内联条件" class="article-heading"><a href="#内联条件" class="headerlink" title="内联条件"></a><span id="inline_conditions">内联条件</span><a class="article-anchor" href="#内联条件" aria-hidden="true"></a></h3><p>Query conditions can be inlined into methods like <code>First</code> and <code>Find</code> in a similar way to <code>Where</code>.</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Get by primary key if it were a non-integer type</span></span><br><span class="line">db.First(&amp;user, <span class="string">"id = ?"</span>, <span class="string">"string_primary_key"</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = 'string_primary_key';</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Plain SQL</span></span><br><span class="line">db.Find(&amp;user, <span class="string">"name = ?"</span>, <span class="string">"jinzhu"</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = "jinzhu";</span></span><br><span class="line"></span><br><span class="line">db.Find(&amp;users, <span class="string">"name &lt;&gt; ? AND age &gt; ?"</span>, <span class="string">"jinzhu"</span>, <span class="number">20</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name &lt;&gt; "jinzhu" AND age &gt; 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Struct</span></span><br><span class="line">db.Find(&amp;users, User{Age: <span class="number">20</span>})</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE age = 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line">db.Find(&amp;users, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{<span class="string">"age"</span>: <span class="number">20</span>})</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE age = 20;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Not-条件" class="article-heading"><a href="#Not-条件" class="headerlink" title="Not 条件"></a>Not 条件<a class="article-anchor" href="#Not-条件" aria-hidden="true"></a></h3><p>Build NOT conditions, works similar to <code>Where</code></p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">db.Not(<span class="string">"name = ?"</span>, <span class="string">"jinzhu"</span>).First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE NOT name = "jinzhu" ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Not In</span></span><br><span class="line">db.Not(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{<span class="string">"name"</span>: []<span class="type">string</span>{<span class="string">"jinzhu"</span>, <span class="string">"jinzhu 2"</span>}}).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name NOT IN ("jinzhu", "jinzhu 2");</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Struct</span></span><br><span class="line">db.Not(User{Name: <span class="string">"jinzhu"</span>, Age: <span class="number">18</span>}).First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name &lt;&gt; "jinzhu" AND age &lt;&gt; 18 ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Not In slice of primary keys</span></span><br><span class="line">db.Not([]<span class="type">int64</span>{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>}).First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id NOT IN (1,2,3) ORDER BY id LIMIT 1;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Or-条件" class="article-heading"><a href="#Or-条件" class="headerlink" title="Or 条件"></a>Or 条件<a class="article-anchor" href="#Or-条件" aria-hidden="true"></a></h3><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">db.Where(<span class="string">"role = ?"</span>, <span class="string">"admin"</span>).Or(<span class="string">"role = ?"</span>, <span class="string">"super_admin"</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE role = 'admin' OR role = 'super_admin';</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Struct</span></span><br><span class="line">db.Where(<span class="string">"name = 'jinzhu'"</span>).Or(User{Name: <span class="string">"jinzhu 2"</span>, Age: <span class="number">18</span>}).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = 'jinzhu' OR (name = 'jinzhu 2' AND age = 18);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line">db.Where(<span class="string">"name = 'jinzhu'"</span>).Or(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{<span class="string">"name"</span>: <span class="string">"jinzhu 2"</span>, <span class="string">"age"</span>: <span class="number">18</span>}).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = 'jinzhu' OR (name = 'jinzhu 2' AND age = 18);</span></span><br></pre></td></tr></tbody></table></figure><p>For more complicated SQL queries. please also refer to <a href="advanced_query.html#group_conditions">Group Conditions in Advanced Query</a>.</p><h2 id="选择特定字段" class="article-heading"><a href="#选择特定字段" class="headerlink" title="选择特定字段"></a>选择特定字段<a class="article-anchor" href="#选择特定字段" aria-hidden="true"></a></h2><p><code>Select</code> allows you to specify the fields that you want to retrieve from database. Otherwise, GORM will select all fields by default.</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">db.Select(<span class="string">"name"</span>, <span class="string">"age"</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT name, age FROM users;</span></span><br><span class="line"></span><br><span class="line">db.Select([]<span class="type">string</span>{<span class="string">"name"</span>, <span class="string">"age"</span>}).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT name, age FROM users;</span></span><br><span class="line"></span><br><span class="line">db.Table(<span class="string">"users"</span>).Select(<span class="string">"COALESCE(age,?)"</span>, <span class="number">42</span>).Rows()</span><br><span class="line"><span class="comment">// SELECT COALESCE(age,'42') FROM users;</span></span><br></pre></td></tr></tbody></table></figure><p>Also check out <a href="advanced_query.html#smart_select">Smart Select Fields</a></p><h2 id="Order" class="article-heading"><a href="#Order" class="headerlink" title="Order"></a>Order<a class="article-anchor" href="#Order" aria-hidden="true"></a></h2><p>Specify order when retrieving records from the database</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">db.Order(<span class="string">"age desc, name"</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users ORDER BY age desc, name;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Multiple orders</span></span><br><span class="line">db.Order(<span class="string">"age desc"</span>).Order(<span class="string">"name"</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users ORDER BY age desc, name;</span></span><br><span class="line"></span><br><span class="line">db.Clauses(clause.OrderBy{</span><br><span class="line">  Expression: clause.Expr{SQL: <span class="string">"FIELD(id,?)"</span>, Vars: []<span class="keyword">interface</span>{}{[]<span class="type">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}}, WithoutParentheses: <span class="literal">true</span>},</span><br><span class="line">}).Find(&amp;User{})</span><br><span class="line"><span class="comment">// SELECT * FROM users ORDER BY FIELD(id,1,2,3)</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Limit-amp-Offset" class="article-heading"><a href="#Limit-amp-Offset" class="headerlink" title="Limit &amp; Offset"></a>Limit &amp; Offset<a class="article-anchor" href="#Limit-amp-Offset" aria-hidden="true"></a></h2><p><code>Limit</code> specify the max number of records to retrieve <code>Offset</code> specify the number of records to skip before starting to return the records</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">db.Limit(<span class="number">3</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users LIMIT 3;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Cancel limit condition with -1</span></span><br><span class="line">db.Limit(<span class="number">10</span>).Find(&amp;users1).Limit(<span class="number">-1</span>).Find(&amp;users2)</span><br><span class="line"><span class="comment">// SELECT * FROM users LIMIT 10; (users1)</span></span><br><span class="line"><span class="comment">// SELECT * FROM users; (users2)</span></span><br><span class="line"></span><br><span class="line">db.Offset(<span class="number">3</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users OFFSET 3;</span></span><br><span class="line"></span><br><span class="line">db.Limit(<span class="number">10</span>).Offset(<span class="number">5</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users OFFSET 5 LIMIT 10;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Cancel offset condition with -1</span></span><br><span class="line">db.Offset(<span class="number">10</span>).Find(&amp;users1).Offset(<span class="number">-1</span>).Find(&amp;users2)</span><br><span class="line"><span class="comment">// SELECT * FROM users OFFSET 10; (users1)</span></span><br><span class="line"><span class="comment">// SELECT * FROM users; (users2)</span></span><br></pre></td></tr></tbody></table></figure><p>Refer to <a href="scopes.html#pagination">Pagination</a> for details on how to make a paginator</p><h2 id="Group-By-amp-Having" class="article-heading"><a href="#Group-By-amp-Having" class="headerlink" title="Group By &amp; Having"></a>Group By &amp; Having<a class="article-anchor" href="#Group-By-amp-Having" aria-hidden="true"></a></h2><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> result <span class="keyword">struct</span> {</span><br><span class="line">  Date  time.Time</span><br><span class="line">  Total <span class="type">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">db.Model(&amp;User{}).Select(<span class="string">"name, sum(age) as total"</span>).Where(<span class="string">"name LIKE ?"</span>, <span class="string">"group%"</span>).Group(<span class="string">"name"</span>).First(&amp;result)</span><br><span class="line"><span class="comment">// SELECT name, sum(age) as total FROM `users` WHERE name LIKE "group%" GROUP BY `name` LIMIT 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">db.Model(&amp;User{}).Select(<span class="string">"name, sum(age) as total"</span>).Group(<span class="string">"name"</span>).Having(<span class="string">"name = ?"</span>, <span class="string">"group"</span>).Find(&amp;result)</span><br><span class="line"><span class="comment">// SELECT name, sum(age) as total FROM `users` GROUP BY `name` HAVING name = "group"</span></span><br><span class="line"></span><br><span class="line">rows, err := db.Table(<span class="string">"orders"</span>).Select(<span class="string">"date(created_at) as date, sum(amount) as total"</span>).Group(<span class="string">"date(created_at)"</span>).Rows()</span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"><span class="keyword">for</span> rows.Next() {</span><br><span class="line">  ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">rows, err := db.Table(<span class="string">"orders"</span>).Select(<span class="string">"date(created_at) as date, sum(amount) as total"</span>).Group(<span class="string">"date(created_at)"</span>).Having(<span class="string">"sum(amount) &gt; ?"</span>, <span class="number">100</span>).Rows()</span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"><span class="keyword">for</span> rows.Next() {</span><br><span class="line">  ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> {</span><br><span class="line">  Date  time.Time</span><br><span class="line">  Total <span class="type">int64</span></span><br><span class="line">}</span><br><span class="line">db.Table(<span class="string">"orders"</span>).Select(<span class="string">"date(created_at) as date, sum(amount) as total"</span>).Group(<span class="string">"date(created_at)"</span>).Having(<span class="string">"sum(amount) &gt; ?"</span>, <span class="number">100</span>).Scan(&amp;results)</span><br></pre></td></tr></tbody></table></figure><h2 id="Distinct" class="article-heading"><a href="#Distinct" class="headerlink" title="Distinct"></a>Distinct<a class="article-anchor" href="#Distinct" aria-hidden="true"></a></h2><p>Selecting distinct values from the model</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">db.Distinct(<span class="string">"name"</span>, <span class="string">"age"</span>).Order(<span class="string">"name, age desc"</span>).Find(&amp;results)</span><br></pre></td></tr></tbody></table></figure><p><code>Distinct</code> works with <a href="advanced_query.html#pluck"><code>Pluck</code></a> and <a href="advanced_query.html#count"><code>Count</code></a> too</p><h2 id="Joins" class="article-heading"><a href="#Joins" class="headerlink" title="Joins"></a>Joins<a class="article-anchor" href="#Joins" aria-hidden="true"></a></h2><p>Specify Joins conditions</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> result <span class="keyword">struct</span> {</span><br><span class="line">  Name  <span class="type">string</span></span><br><span class="line">  Email <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">db.Model(&amp;User{}).Select(<span class="string">"users.name, emails.email"</span>).Joins(<span class="string">"left join emails on emails.user_id = users.id"</span>).Scan(&amp;result{})</span><br><span class="line"><span class="comment">// SELECT users.name, emails.email FROM `users` left join emails on emails.user_id = users.id</span></span><br><span class="line"></span><br><span class="line">rows, err := db.Table(<span class="string">"users"</span>).Select(<span class="string">"users.name, emails.email"</span>).Joins(<span class="string">"left join emails on emails.user_id = users.id"</span>).Rows()</span><br><span class="line"><span class="keyword">for</span> rows.Next() {</span><br><span class="line">  ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">db.Table(<span class="string">"users"</span>).Select(<span class="string">"users.name, emails.email"</span>).Joins(<span class="string">"left join emails on emails.user_id = users.id"</span>).Scan(&amp;results)</span><br><span class="line"></span><br><span class="line"><span class="comment">// multiple joins with parameter</span></span><br><span class="line">db.Joins(<span class="string">"JOIN emails ON emails.user_id = users.id AND emails.email = ?"</span>, <span class="string">"jinzhu@example.org"</span>).Joins(<span class="string">"JOIN credit_cards ON credit_cards.user_id = users.id"</span>).Where(<span class="string">"credit_cards.number = ?"</span>, <span class="string">"411111111111"</span>).Find(&amp;user)</span><br></pre></td></tr></tbody></table></figure><h3 id="Joins-预加载" class="article-heading"><a href="#Joins-预加载" class="headerlink" title="Joins 预加载"></a>Joins 预加载<a class="article-anchor" href="#Joins-预加载" aria-hidden="true"></a></h3><p>You can use <code>Joins</code> eager loading associations with a single SQL, for example:</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">db.Joins(<span class="string">"Company"</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT `users`.`id`,`users`.`name`,`users`.`age`,`Company`.`id` AS `Company__id`,`Company`.`name` AS `Company__name` FROM `users` LEFT JOIN `companies` AS `Company` ON `users`.`company_id` = `Company`.`id`;</span></span><br></pre></td></tr></tbody></table></figure><p>Join with conditions</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">db.Joins(<span class="string">"Company"</span>, db.Where(&amp;Company{Alive: <span class="literal">true</span>})).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT `users`.`id`,`users`.`name`,`users`.`age`,`Company`.`id` AS `Company__id`,`Company`.`name` AS `Company__name` FROM `users` LEFT JOIN `companies` AS `Company` ON `users`.`company_id` = `Company`.`id` AND `Company`.`alive` = true;</span></span><br></pre></td></tr></tbody></table></figure><p>For more details, please refer to <a href="preload.html">Preloading (Eager Loading)</a>.</p><h3 id="Joins-a-Derived-Table" class="article-heading"><a href="#Joins-a-Derived-Table" class="headerlink" title="Joins a Derived Table"></a>Joins a Derived Table<a class="article-anchor" href="#Joins-a-Derived-Table" aria-hidden="true"></a></h3><p>You can also use <code>Joins</code> to join a derived table.</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> {</span><br><span class="line">    Id  <span class="type">int</span></span><br><span class="line">    Age <span class="type">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Order <span class="keyword">struct</span> {</span><br><span class="line">    UserId     <span class="type">int</span></span><br><span class="line">    FinishedAt *time.Time</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">query := db.Table(<span class="string">"order"</span>).Select(<span class="string">"MAX(order.finished_at) as latest"</span>).Joins(<span class="string">"left join user user on order.user_id = user.id"</span>).Where(<span class="string">"user.age &gt; ?"</span>, <span class="number">18</span>).Group(<span class="string">"order.user_id"</span>)</span><br><span class="line">db.Model(&amp;Order{}).Joins(<span class="string">"join (?) q on order.finished_at = q.latest"</span>, query).Scan(&amp;results)</span><br><span class="line"><span class="comment">// SELECT `order`.`user_id`,`order`.`finished_at` FROM `order` join (SELECT MAX(order.finished_at) as latest FROM `order` left join user user on order.user_id = user.id WHERE user.age &gt; 18 GROUP BY `order`.`user_id`) q on order.finished_at = q.latest</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Scan" class="article-heading"><a href="#Scan" class="headerlink" title="Scan"></a><span id="scan">Scan</span><a class="article-anchor" href="#Scan" aria-hidden="true"></a></h2><p>Scanning results into a struct works similarly to the way we use <code>Find</code></p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> {</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  Age  <span class="type">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result Result</span><br><span class="line">db.Table(<span class="string">"users"</span>).Select(<span class="string">"name"</span>, <span class="string">"age"</span>).Where(<span class="string">"name = ?"</span>, <span class="string">"Antonio"</span>).Scan(&amp;result)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Raw SQL</span></span><br><span class="line">db.Raw(<span class="string">"SELECT name, age FROM users WHERE name = ?"</span>, <span class="string">"Antonio"</span>).Scan(&amp;result)</span><br></pre></td></tr></tbody></table></figure></body></html>              </div>                            <div>