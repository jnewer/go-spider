<div class="article">            <div class="inner">              <header class="article-header">                <h1 class="article-title" itemprop="name">DBResolver</h1>                                <a target="_blank" rel="noopener" href="https://translate.gorm.io/project/go-gorm/zh-CN" class="article-edit-link" title="改进此页面"><i class="fa fa-pencil"></i></a>                              </header>              <div class="article-content" itemprop="articleBody">                <html><head></head><body><p>DBResolver 为 GORM 提供了多个数据库支持，支持以下功能：</p><ul><li>支持多个 sources、replicas</li><li>读写分离</li><li>根据工作表、struct 自动切换连接</li><li>手动切换连接</li><li>Sources/Replicas 负载均衡</li><li>适用于原生 SQL</li><li>Transaction</li></ul><p><a target="_blank" rel="noopener" href="https://github.com/go-gorm/dbresolver">https://github.com/go-gorm/dbresolver</a></p><h2 id="用法" class="article-heading"><a href="#用法" class="headerlink" title="用法"></a>用法<a class="article-anchor" href="#用法" aria-hidden="true"></a></h2><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"gorm.io/gorm"</span></span><br><span class="line">  <span class="string">"gorm.io/plugin/dbresolver"</span></span><br><span class="line">  <span class="string">"gorm.io/driver/mysql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">db, err := gorm.Open(mysql.Open(<span class="string">"db1_dsn"</span>), &amp;gorm.Config{})</span><br><span class="line"></span><br><span class="line">db.Use(dbresolver.Register(dbresolver.Config{</span><br><span class="line">  <span class="comment">// `db2` 作为 sources，`db3`、`db4` 作为 replicas</span></span><br><span class="line">  Sources:  []gorm.Dialector{mysql.Open(<span class="string">"db2_dsn"</span>)},</span><br><span class="line">  Replicas: []gorm.Dialector{mysql.Open(<span class="string">"db3_dsn"</span>), mysql.Open(<span class="string">"db4_dsn"</span>)},</span><br><span class="line">  <span class="comment">// sources/replicas 负载均衡策略</span></span><br><span class="line">  Policy: dbresolver.RandomPolicy{},</span><br><span class="line">}).Register(dbresolver.Config{</span><br><span class="line">  <span class="comment">// `db1` 作为 sources（DB 的默认连接），对于 `User`、`Address` 使用 `db5` 作为 replicas</span></span><br><span class="line">  Replicas: []gorm.Dialector{mysql.Open(<span class="string">"db5_dsn"</span>)},</span><br><span class="line">}, &amp;User{}, &amp;Address{}).Register(dbresolver.Config{</span><br><span class="line">  <span class="comment">// `db6`、`db7` 作为 sources，对于 `orders`、`Product` 使用 `db8` 作为 replicas</span></span><br><span class="line">  Sources:  []gorm.Dialector{mysql.Open(<span class="string">"db6_dsn"</span>), mysql.Open(<span class="string">"db7_dsn"</span>)},</span><br><span class="line">  Replicas: []gorm.Dialector{mysql.Open(<span class="string">"db8_dsn"</span>)},</span><br><span class="line">}, <span class="string">"orders"</span>, &amp;Product{}, <span class="string">"secondary"</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="Automatic-connection-switching" class="article-heading"><a href="#Automatic-connection-switching" class="headerlink" title="Automatic connection switching"></a>Automatic connection switching<a class="article-anchor" href="#Automatic-connection-switching" aria-hidden="true"></a></h2><p>DBResolver will automatically switch connection based on the working table/struct</p><p>For RAW SQL, DBResolver will extract the table name from the SQL to match the resolver, and will use <code>sources</code> unless the SQL begins with <code>SELECT</code> (excepts <code>SELECT... FOR UPDATE</code>), for example:</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// `User` Resolver 示例</span></span><br><span class="line">db.Table(<span class="string">"users"</span>).Rows() <span class="comment">// replicas `db5`</span></span><br><span class="line">db.Model(&amp;User{}).Find(&amp;AdvancedUser{}) <span class="comment">// replicas `db5`</span></span><br><span class="line">db.Exec(<span class="string">"update users set name = ?"</span>, <span class="string">"jinzhu"</span>) <span class="comment">// sources `db1`</span></span><br><span class="line">db.Raw(<span class="string">"select name from users"</span>).Row().Scan(&amp;name) <span class="comment">// replicas `db5`</span></span><br><span class="line">db.Create(&amp;user) <span class="comment">// sources `db1`</span></span><br><span class="line">db.Delete(&amp;User{}, <span class="string">"name = ?"</span>, <span class="string">"jinzhu"</span>) <span class="comment">// sources `db1`</span></span><br><span class="line">db.Table(<span class="string">"users"</span>).Update(<span class="string">"name"</span>, <span class="string">"jinzhu"</span>) <span class="comment">// sources `db1`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Global Resolver 示例</span></span><br><span class="line">db.Find(&amp;Pet{}) <span class="comment">// replicas `db3`/`db4`</span></span><br><span class="line">db.Save(&amp;Pet{}) <span class="comment">// sources `db2`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Orders Resolver 示例</span></span><br><span class="line">db.Find(&amp;Order{}) <span class="comment">// replicas `db8`</span></span><br><span class="line">db.Table(<span class="string">"orders"</span>).Find(&amp;Report{}) <span class="comment">// replicas `db8`</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Read-x2F-Write-Splitting" class="article-heading"><a href="#Read-x2F-Write-Splitting" class="headerlink" title="Read/Write Splitting"></a>Read/Write Splitting<a class="article-anchor" href="#Read-x2F-Write-Splitting" aria-hidden="true"></a></h2><p>Read/Write splitting with DBResolver based on the current used <a href="https://gorm.io/docs/write_plugins.html">GORM callbacks</a>.</p><p>For <code>Query</code>, <code>Row</code> callback, will use <code>replicas</code> unless <code>Write</code> mode specified For <code>Raw</code> callback, statements are considered read-only and will use <code>replicas</code> if the SQL starts with <code>SELECT</code></p><h2 id="Manual-connection-switching" class="article-heading"><a href="#Manual-connection-switching" class="headerlink" title="Manual connection switching"></a>Manual connection switching<a class="article-anchor" href="#Manual-connection-switching" aria-hidden="true"></a></h2><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 Write 模式：从 sources db `db1` 读取 user</span></span><br><span class="line">db.Clauses(dbresolver.Write).First(&amp;user)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定 Resolver：从 `secondary` 的 replicas db `db8` 读取 user</span></span><br><span class="line">db.Clauses(dbresolver.Use(<span class="string">"secondary"</span>)).First(&amp;user)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定 Resolver 和 Write 模式：从 `secondary` 的 sources db `db6` 或 `db7` 读取 user</span></span><br><span class="line">db.Clauses(dbresolver.Use(<span class="string">"secondary"</span>), dbresolver.Write).First(&amp;user)</span><br></pre></td></tr></tbody></table></figure><h2 id="Transaction" class="article-heading"><a href="#Transaction" class="headerlink" title="Transaction"></a>Transaction<a class="article-anchor" href="#Transaction" aria-hidden="true"></a></h2><p>When using transaction, DBResolver will keep using the transaction and won’t switch to sources/replicas based on configuration</p><p>But you can specifies which DB to use before starting a transaction, for example:</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Start transaction based on default replicas db</span></span><br><span class="line">tx := DB.Clauses(dbresolver.Read).Begin()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start transaction based on default sources db</span></span><br><span class="line">tx := DB.Clauses(dbresolver.Write).Begin()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start transaction based on `secondary`'s sources</span></span><br><span class="line">tx := DB.Clauses(dbresolver.Use(<span class="string">"secondary"</span>), dbresolver.Write).Begin()</span><br></pre></td></tr></tbody></table></figure><h2 id="负载均衡" class="article-heading"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡<a class="article-anchor" href="#负载均衡" aria-hidden="true"></a></h2><p>GORM supports load balancing sources/replicas based on policy, the policy should be a struct implements following interface:</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Policy <span class="keyword">interface</span> {</span><br><span class="line">    Resolve([]gorm.ConnPool) gorm.ConnPool</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Currently only the <code>RandomPolicy</code> implemented and it is the default option if no other policy specified.</p><h2 id="连接池" class="article-heading"><a href="#连接池" class="headerlink" title="连接池"></a>连接池<a class="article-anchor" href="#连接池" aria-hidden="true"></a></h2><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">db.Use(</span><br><span class="line">  dbresolver.Register(dbresolver.Config{ <span class="comment">/* xxx */</span> }).</span><br><span class="line">  SetConnMaxIdleTime(time.Hour).</span><br><span class="line">  SetConnMaxLifetime(<span class="number">24</span> * time.Hour).</span><br><span class="line">  SetMaxIdleConns(<span class="number">100</span>).</span><br><span class="line">  SetMaxOpenConns(<span class="number">200</span>)</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure></body></html>              </div>                            <div>