<div class="article">            <div class="inner">              <header class="article-header">                <h1 class="article-title" itemprop="name">创建</h1>                                <a target="_blank" rel="noopener" href="https://translate.gorm.io/project/go-gorm/zh-CN" class="article-edit-link" title="改进此页面"><i class="fa fa-pencil"></i></a>                              </header>              <div class="article-content" itemprop="articleBody">                <html><head></head><body><h2 id="创建记录" class="article-heading"><a href="#创建记录" class="headerlink" title="创建记录"></a>创建记录<a class="article-anchor" href="#创建记录" aria-hidden="true"></a></h2><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">user := User{Name: <span class="string">"Jinzhu"</span>, Age: <span class="number">18</span>, Birthday: time.Now()}</span><br><span class="line"></span><br><span class="line">result := db.Create(&amp;user) <span class="comment">// 通过数据的指针来创建</span></span><br><span class="line"></span><br><span class="line">user.ID             <span class="comment">// 返回插入数据的主键</span></span><br><span class="line">result.Error        <span class="comment">// 返回 error</span></span><br><span class="line">result.RowsAffected <span class="comment">// 返回插入记录的条数</span></span><br></pre></td></tr></tbody></table></figure><h2 id="用指定的字段创建记录" class="article-heading"><a href="#用指定的字段创建记录" class="headerlink" title="用指定的字段创建记录"></a>用指定的字段创建记录<a class="article-anchor" href="#用指定的字段创建记录" aria-hidden="true"></a></h2><p>创建记录并更新给出的字段。</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">db.Select(<span class="string">"Name"</span>, <span class="string">"Age"</span>, <span class="string">"CreatedAt"</span>).Create(&amp;user)</span><br><span class="line"><span class="comment">// INSERT INTO `users` (`name`,`age`,`created_at`) VALUES ("jinzhu", 18, "2020-07-04 11:05:21.775")</span></span><br></pre></td></tr></tbody></table></figure><p>创建一个记录且一同忽略传递给略去的字段值。</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">db.Omit(<span class="string">"Name"</span>, <span class="string">"Age"</span>, <span class="string">"CreatedAt"</span>).Create(&amp;user)</span><br><span class="line"><span class="comment">// INSERT INTO `users` (`birthday`,`updated_at`) VALUES ("2020-01-01 00:00:00.000", "2020-07-04 11:05:21.775")</span></span><br></pre></td></tr></tbody></table></figure><h2 id="批量插入" class="article-heading"><a href="#批量插入" class="headerlink" title="批量插入"></a><span id="batch_insert">批量插入</span><a class="article-anchor" href="#批量插入" aria-hidden="true"></a></h2><p>要有效地插入大量记录，请将一个 <code>slice</code> 传递给 <code>Create</code> 方法。 GORM 将生成单独一条SQL语句来插入所有数据，并回填主键的值，钩子方法也会被调用。</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> users = []User{{Name: <span class="string">"jinzhu1"</span>}, {Name: <span class="string">"jinzhu2"</span>}, {Name: <span class="string">"jinzhu3"</span>}}</span><br><span class="line">db.Create(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, user := <span class="keyword">range</span> users {</span><br><span class="line">  user.ID <span class="comment">// 1,2,3</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用 <code>CreateInBatches</code> 分批创建时，你可以指定每批的数量，例如：</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> users = []User{{name: <span class="string">"jinzhu_1"</span>}, ...., {Name: <span class="string">"jinzhu_10000"</span>}}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数量为 100</span></span><br><span class="line">db.CreateInBatches(users, <span class="number">100</span>)</span><br></pre></td></tr></tbody></table></figure><p><a href="#upsert">Upsert</a> 和 <a href="#create_with_associations">Create With Associations</a> 也支持批量插入</p><blockquote class="note warn"><p><strong>注意</strong> 使用<code>CreateBatchSize</code> 选项初始化 GORM 时，所有的创建&amp; 关联 <code>INSERT</code> 都将遵循该选项</p></blockquote><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">db, err := gorm.Open(sqlite.Open(<span class="string">"gorm.db"</span>), &amp;gorm.Config{</span><br><span class="line">  CreateBatchSize: <span class="number">1000</span>,</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">db := db.Session(&amp;gorm.Session{CreateBatchSize: <span class="number">1000</span>})</span><br><span class="line"></span><br><span class="line">users = [<span class="number">5000</span>]User{{Name: <span class="string">"jinzhu"</span>, Pets: []Pet{pet1, pet2, pet3}}...}</span><br><span class="line"></span><br><span class="line">db.Create(&amp;users)</span><br><span class="line"><span class="comment">// INSERT INTO users xxx (5 batches)</span></span><br><span class="line"><span class="comment">// INSERT INTO pets xxx (15 batches)</span></span><br></pre></td></tr></tbody></table></figure><h2 id="创建钩子" class="article-heading"><a href="#创建钩子" class="headerlink" title="创建钩子"></a>创建钩子<a class="article-anchor" href="#创建钩子" aria-hidden="true"></a></h2><p>GORM 允许用户定义的钩子有 <code>BeforeSave</code>, <code>BeforeCreate</code>, <code>AfterSave</code>, <code>AfterCreate</code>  创建记录时将调用这些钩子方法，请参考 <a href="hooks.html">Hooks</a> 中关于生命周期的详细信息</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span></span> BeforeCreate(tx *gorm.DB) (err <span class="type">error</span>) {</span><br><span class="line">  u.UUID = uuid.New()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> u.Role == <span class="string">"admin"</span> {</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">"invalid role"</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果您想跳过 <code>钩子</code> 方法，您可以使用 <code>SkipHooks</code> 会话模式，例如：</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">DB.Session(&amp;gorm.Session{SkipHooks: <span class="literal">true</span>}).Create(&amp;user)</span><br><span class="line"></span><br><span class="line">DB.Session(&amp;gorm.Session{SkipHooks: <span class="literal">true</span>}).Create(&amp;users)</span><br><span class="line"></span><br><span class="line">DB.Session(&amp;gorm.Session{SkipHooks: <span class="literal">true</span>}).CreateInBatches(users, <span class="number">100</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="根据-Map-创建" class="article-heading"><a href="#根据-Map-创建" class="headerlink" title="根据 Map 创建"></a>根据 Map 创建<a class="article-anchor" href="#根据-Map-创建" aria-hidden="true"></a></h2><p>GORM 支持根据 <code>map[string]interface{}</code> 和 <code>[]map[string]interface{}{}</code> 创建记录，例如：</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">db.Model(&amp;User{}).Create(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{</span><br><span class="line">  <span class="string">"Name"</span>: <span class="string">"jinzhu"</span>, <span class="string">"Age"</span>: <span class="number">18</span>,</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="comment">// batch insert from `[]map[string]interface{}{}`</span></span><br><span class="line">db.Model(&amp;User{}).Create([]<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{</span><br><span class="line">  {<span class="string">"Name"</span>: <span class="string">"jinzhu_1"</span>, <span class="string">"Age"</span>: <span class="number">18</span>},</span><br><span class="line">  {<span class="string">"Name"</span>: <span class="string">"jinzhu_2"</span>, <span class="string">"Age"</span>: <span class="number">20</span>},</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><blockquote class="note warn"><p><strong>注意：</strong> 根据 map 创建记录时，association 不会被调用，且主键也不会自动填充</p></blockquote><h2 id="使用-SQL-表达式、Context-Valuer-创建记录" class="article-heading"><a href="#使用-SQL-表达式、Context-Valuer-创建记录" class="headerlink" title="使用 SQL 表达式、Context Valuer 创建记录"></a><span id="create_from_sql_expr">使用 SQL 表达式、Context Valuer 创建记录</span><a class="article-anchor" href="#使用-SQL-表达式、Context-Valuer-创建记录" aria-hidden="true"></a></h2><p>GORM 允许使用 SQL 表达式插入数据，有两种方法实现这个目标。根据 <code>map[string]interface{}</code> 或 <a href="data_types.html#gorm_valuer_interface">自定义数据类型</a> 创建，例如：</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 map 创建记录</span></span><br><span class="line">db.Model(User{}).Create(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{</span><br><span class="line">  <span class="string">"Name"</span>: <span class="string">"jinzhu"</span>,</span><br><span class="line">  <span class="string">"Location"</span>: clause.Expr{SQL: <span class="string">"ST_PointFromText(?)"</span>, Vars: []<span class="keyword">interface</span>{}{<span class="string">"POINT(100 100)"</span>}},</span><br><span class="line">})</span><br><span class="line"><span class="comment">// INSERT INTO `users` (`name`,`location`) VALUES ("jinzhu",ST_PointFromText("POINT(100 100)"));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过自定义类型创建记录</span></span><br><span class="line"><span class="keyword">type</span> Location <span class="keyword">struct</span> {</span><br><span class="line">    X, Y <span class="type">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scan 方法实现了 sql.Scanner 接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(loc *Location)</span></span> Scan(v <span class="keyword">interface</span>{}) <span class="type">error</span> {</span><br><span class="line">  <span class="comment">// Scan a value into struct from database driver</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(loc Location)</span></span> GormDataType() <span class="type">string</span> {</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"geometry"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(loc Location)</span></span> GormValue(ctx context.Context, db *gorm.DB) clause.Expr {</span><br><span class="line">  <span class="keyword">return</span> clause.Expr{</span><br><span class="line">    SQL:  <span class="string">"ST_PointFromText(?)"</span>,</span><br><span class="line">    Vars: []<span class="keyword">interface</span>{}{fmt.Sprintf(<span class="string">"POINT(%d %d)"</span>, loc.X, loc.Y)},</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> {</span><br><span class="line">  Name     <span class="type">string</span></span><br><span class="line">  Location Location</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">db.Create(&amp;User{</span><br><span class="line">  Name:     <span class="string">"jinzhu"</span>,</span><br><span class="line">  Location: Location{X: <span class="number">100</span>, Y: <span class="number">100</span>},</span><br><span class="line">})</span><br><span class="line"><span class="comment">// INSERT INTO `users` (`name`,`location`) VALUES ("jinzhu",ST_PointFromText("POINT(100 100)"))</span></span><br></pre></td></tr></tbody></table></figure><h2 id="高级选项" class="article-heading"><a href="#高级选项" class="headerlink" title="高级选项"></a>高级选项<a class="article-anchor" href="#高级选项" aria-hidden="true"></a></h2><h3 id="关联创建" class="article-heading"><a href="#关联创建" class="headerlink" title="关联创建"></a><span id="create_with_associations">关联创建</span><a class="article-anchor" href="#关联创建" aria-hidden="true"></a></h3><p>创建关联数据时，如果关联值是非零值，这些关联会被 upsert，且它们的 <code>Hook</code> 方法也会被调用</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> CreditCard <span class="keyword">struct</span> {</span><br><span class="line">  gorm.Model</span><br><span class="line">  Number   <span class="type">string</span></span><br><span class="line">  UserID   <span class="type">uint</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> {</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name       <span class="type">string</span></span><br><span class="line">  CreditCard CreditCard</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">db.Create(&amp;User{</span><br><span class="line">  Name: <span class="string">"jinzhu"</span>,</span><br><span class="line">  CreditCard: CreditCard{Number: <span class="string">"411111111111"</span>}</span><br><span class="line">})</span><br><span class="line"><span class="comment">// INSERT INTO `users` ...</span></span><br><span class="line"><span class="comment">// INSERT INTO `credit_cards` ...</span></span><br></pre></td></tr></tbody></table></figure><p>您也可以通过 <code>Select</code>、 <code>Omit</code> 跳过关联保存，例如：</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">db.Omit(<span class="string">"CreditCard"</span>).Create(&amp;user)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳过所有关联</span></span><br><span class="line">db.Omit(clause.Associations).Create(&amp;user)</span><br></pre></td></tr></tbody></table></figure><h3 id="默认值" class="article-heading"><a href="#默认值" class="headerlink" title="默认值"></a><span id="default_values">默认值</span><a class="article-anchor" href="#默认值" aria-hidden="true"></a></h3><p>您可以通过标签 <code>default</code> 为字段定义默认值，如：</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> {</span><br><span class="line">  ID   <span class="type">int64</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:"default:galeone"`</span></span><br><span class="line">  Age  <span class="type">int64</span>  <span class="string">`gorm:"default:18"`</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>插入记录到数据库时，默认值 <em>会被用于</em> 填充值为 <a target="_blank" rel="noopener" href="https://tour.golang.org/basics/12">零值</a> 的字段</p><blockquote class="note warn"><p><strong>注意</strong> 对于声明了默认值的字段，像 <code>0</code>、<code>''</code>、<code>false</code> 等零值是不会保存到数据库。您需要使用指针类型或 Scanner/Valuer 来避免这个问题，例如：</p></blockquote><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> {</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  Age  *<span class="type">int</span>           <span class="string">`gorm:"default:18"`</span></span><br><span class="line">  Active sql.NullBool <span class="string">`gorm:"default:true"`</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote class="note warn"><p><strong>注意</strong> 若要数据库有默认、虚拟/生成的值，你必须为字段设置 <code>default</code> 标签。若要在迁移时跳过默认值定义，你可以使用 <code>default:(-)</code>，例如：</p></blockquote><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> {</span><br><span class="line">  ID        <span class="type">string</span> <span class="string">`gorm:"default:uuid_generate_v3()"`</span> <span class="comment">// db func</span></span><br><span class="line">  FirstName <span class="type">string</span></span><br><span class="line">  LastName  <span class="type">string</span></span><br><span class="line">  Age       <span class="type">uint8</span></span><br><span class="line">  FullName  <span class="type">string</span> <span class="string">`gorm:"-&gt;;type:GENERATED ALWAYS AS (concat(firstname,' ',lastname));default:(-);"`</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用虚拟/生成的值时，你可能需要禁用它的创建、更新权限，查看 <a href="models.html#field_permission">字段级权限</a> 获取详情</p><h3 id="Upsert-及冲突" class="article-heading"><a href="#Upsert-及冲突" class="headerlink" title="Upsert 及冲突"></a><span id="upsert">Upsert 及冲突</span><a class="article-anchor" href="#Upsert-及冲突" aria-hidden="true"></a></h3><p>GORM 为不同数据库提供了兼容的 Upsert 支持</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"gorm.io/gorm/clause"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在冲突时，什么都不做</span></span><br><span class="line">db.Clauses(clause.OnConflict{DoNothing: <span class="literal">true</span>}).Create(&amp;user)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在`id`冲突时，将列更新为默认值</span></span><br><span class="line">db.Clauses(clause.OnConflict{</span><br><span class="line">  Columns:   []clause.Column{{Name: <span class="string">"id"</span>}},</span><br><span class="line">  DoUpdates: clause.Assignments(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{<span class="string">"role"</span>: <span class="string">"user"</span>}),</span><br><span class="line">}).Create(&amp;users)</span><br><span class="line"><span class="comment">// MERGE INTO "users" USING *** WHEN NOT MATCHED THEN INSERT *** WHEN MATCHED THEN UPDATE SET ***; SQL Server</span></span><br><span class="line"><span class="comment">// INSERT INTO `users` *** ON DUPLICATE KEY UPDATE ***; MySQL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用SQL语句</span></span><br><span class="line">db.Clauses(clause.OnConflict{</span><br><span class="line">  Columns:   []clause.Column{{Name: <span class="string">"id"</span>}},</span><br><span class="line">  DoUpdates: clause.Assignments(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{<span class="string">"count"</span>: gorm.Expr(<span class="string">"GREATEST(count, VALUES(count))"</span>)}),</span><br><span class="line">}).Create(&amp;users)</span><br><span class="line"><span class="comment">// INSERT INTO `users` *** ON DUPLICATE KEY UPDATE `count`=GREATEST(count, VALUES(count));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在`id`冲突时，将列更新为新值</span></span><br><span class="line">db.Clauses(clause.OnConflict{</span><br><span class="line">  Columns:   []clause.Column{{Name: <span class="string">"id"</span>}},</span><br><span class="line">  DoUpdates: clause.AssignmentColumns([]<span class="type">string</span>{<span class="string">"name"</span>, <span class="string">"age"</span>}),</span><br><span class="line">}).Create(&amp;users)</span><br><span class="line"><span class="comment">// MERGE INTO "users" USING *** WHEN NOT MATCHED THEN INSERT *** WHEN MATCHED THEN UPDATE SET "name"="excluded"."name"; SQL Server</span></span><br><span class="line"><span class="comment">// INSERT INTO "users" *** ON CONFLICT ("id") DO UPDATE SET "name"="excluded"."name", "age"="excluded"."age"; PostgreSQL</span></span><br><span class="line"><span class="comment">// INSERT INTO `users` *** ON DUPLICATE KEY UPDATE `name`=VALUES(name),`age=VALUES(age); MySQL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在冲突时，更新除主键以外的所有列到新值。</span></span><br><span class="line">db.Clauses(clause.OnConflict{</span><br><span class="line">  UpdateAll: <span class="literal">true</span>,</span><br><span class="line">}).Create(&amp;users)</span><br><span class="line"><span class="comment">// INSERT INTO "users" *** ON CONFLICT ("id") DO UPDATE SET "name"="excluded"."name", "age"="excluded"."age", ...;</span></span><br></pre></td></tr></tbody></table></figure><p>您还可以查看 <a href="advanced_query.html">高级查询</a> 中的 <code>FirstOrInit</code>、<code>FirstOrCreate</code></p><p>查看 <a href="sql_builder.html">原生 SQL 及构造器</a> 获取更多细节</p></body></html>              </div>                            <div>